<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: rc522 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="classrc522-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rc522 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classrc522.html" title="rc522 chip class inherits from spiReader ">rc522</a> chip class inherits from <a class="el" href="classspiReader.html" title="spiReader ADT class ">spiReader</a>  
 <a href="classrc522.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rc522_8hpp_source.html">rc522.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rc522:</div>
<div class="dyncontent">
<div class="center"><img src="classrc522__inherit__graph.png" border="0" usemap="#rc522_inherit__map" alt="Inheritance graph"/></div>
<map name="rc522_inherit__map" id="rc522_inherit__map">
<area shape="rect" id="node2" href="classspiReader.html" title="spiReader ADT class " alt="" coords="5,5,87,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for rc522:</div>
<div class="dyncontent">
<div class="center"><img src="classrc522__coll__graph.png" border="0" usemap="#rc522_coll__map" alt="Collaboration graph"/></div>
<map name="rc522_coll__map" id="rc522_coll__map">
<area shape="rect" id="node2" href="classspiReader.html" title="spiReader ADT class " alt="" coords="5,5,87,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a83057db5f8fefa3dc9a6e8e5f0e191ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">registers</a> { <br />
&#160;&#160;<b>Reserved_00</b> = 0x00, 
<b>CommandReg</b> = 0x01, 
<b>ComlEnReg</b> = 0x02, 
<b>DivlEnReg</b> = 0x03, 
<br />
&#160;&#160;<b>ComIrqReg</b> = 0x04, 
<b>DivIrqReg</b> = 0x05, 
<b>ErrorReg</b> = 0x06, 
<b>Status1Reg</b> = 0x07, 
<br />
&#160;&#160;<b>Status2Reg</b> = 0x08, 
<b>FIFODataReg</b> = 0x09, 
<b>FIFOLevelReg</b> = 0x0A, 
<b>WaterLevelReg</b> = 0x0B, 
<br />
&#160;&#160;<b>ControlReg</b> = 0x0C, 
<b>BitFramingReg</b> = 0x0D, 
<b>CollReg</b> = 0x0E, 
<b>Reserved_0F</b> = 0x0F
<br />
 }<tr class="memdesc:a83057db5f8fefa3dc9a6e8e5f0e191ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">A enum class with Addressable Registers.  <a href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a83057db5f8fefa3dc9a6e8e5f0e191ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a205976fb9b7265bc5b7971215fbb7c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">regCommands</a> { <br />
&#160;&#160;<b>Idle</b> = 0x00, 
<b>Mem</b> = 0x01, 
<b>GenerateRandomID</b> = 0x02, 
<b>CalcCRC</b> = 0x03, 
<br />
&#160;&#160;<b>Transmit</b> = 0x04, 
<b>NoCmdChange</b> = 0x07, 
<b>Receive</b> = 0x08, 
<b>Transceive</b> = 0x0C, 
<br />
&#160;&#160;<b>Reserved</b> = 0x0D, 
<b>MFAuthent</b> = 0x0E, 
<b>SoftReset</b> = 0x0F
<br />
 }<tr class="memdesc:a3a205976fb9b7265bc5b7971215fbb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A enum class with register commands for the CommandReg.  <a href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3a205976fb9b7265bc5b7971215fbb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df2359c88d6c2f47faf58bc9e09eaa4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">commands</a> { <br />
&#160;&#160;<b>Reserved_10</b> = 0x10, 
<b>ModeReg</b> = 0x11, 
<b>TxModeReg</b> = 0x12, 
<b>RxModeReg</b> = 0x13, 
<br />
&#160;&#160;<b>TxControlReg</b> = 0x14, 
<b>TxASKReg</b> = 0x15, 
<b>TxSelReg</b> = 0x16, 
<b>RxSelReg</b> = 0x17, 
<br />
&#160;&#160;<b>RxThresholdReg</b> = 0x18, 
<b>DemodReg</b> = 0x19, 
<b>Reserved_1A</b> = 0x1A, 
<b>Reserved_1B</b> = 0x1B, 
<br />
&#160;&#160;<b>MfTxReg</b> = 0x1C, 
<b>MfRxReg</b> = 0x1D, 
<b>Reserved_1E</b> = 0x1E, 
<b>SerialSpeedReg</b> = 0x1F
<br />
 }<tr class="memdesc:a6df2359c88d6c2f47faf58bc9e09eaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A enum class with Addressable Commands.  <a href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6df2359c88d6c2f47faf58bc9e09eaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf27c8198d017cd4e8173c7d7a6fded"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">configuration</a> { <br />
&#160;&#160;<b>Reserved_20</b> = 0x20, 
<b>CRCResultReg_High</b> = 0x21, 
<b>CRCResultReg_Low</b> = 0x22, 
<b>Reserved_23</b> = 0x23, 
<br />
&#160;&#160;<b>ModWidthReg</b> = 0x24, 
<b>Reserved_25</b> = 0x25, 
<b>RFCfgReg</b> = 0x26, 
<b>GsNReg</b> = 0x27, 
<br />
&#160;&#160;<b>CWGsPReg</b> = 0x28, 
<b>ModGsPReg</b> = 0x29, 
<b>TModeReg</b> = 0x2A, 
<b>TPrescalerReg</b> = 0x2B, 
<br />
&#160;&#160;<b>TReloadReg_High</b> = 0x2C, 
<b>TReloadReg_Low</b> = 0x2D, 
<b>TCounterValReg_High</b> = 0x2E, 
<b>TCounterValReg_Low</b> = 0x2F
<br />
 }<tr class="memdesc:afcf27c8198d017cd4e8173c7d7a6fded"><td class="mdescLeft">&#160;</td><td class="mdescRight">A enum class with Addressable Configuration registers.  <a href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afcf27c8198d017cd4e8173c7d7a6fded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9589917c9bbcd18ea9c7d86c7ec565bd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">test</a> { <br />
&#160;&#160;<b>Reserved_30</b> = 0x30, 
<b>TestSel1Reg</b> = 0x31, 
<b>TestSel2Reg</b> = 0x32, 
<b>TestPinEnReg</b> = 0x33, 
<br />
&#160;&#160;<b>TestPinValueReg</b> = 0x34, 
<b>TestBusReg</b> = 0x35, 
<b>AutoTestReg</b> = 0x36, 
<b>VersionReg</b> = 0x37, 
<br />
&#160;&#160;<b>AnalogTestReg</b> = 0x38, 
<b>TestDAC1Reg</b> = 0x39, 
<b>TestDAC2Reg</b> = 0x3A, 
<b>TestADCReg</b> = 0x3B, 
<br />
&#160;&#160;<b>Reserved_3C</b> = 0x3C, 
<b>Reserved_3D</b> = 0x3D, 
<b>Reserved_3E</b> = 0x3E, 
<b>Reserved_3F</b> = 0x3F
<br />
 }<tr class="memdesc:a9589917c9bbcd18ea9c7d86c7ec565bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A enum class with Addressable Test registers.  <a href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9589917c9bbcd18ea9c7d86c7ec565bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classspiReader"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classspiReader')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classspiReader.html">spiReader</a></td></tr>
<tr class="memitem:a4bcf984823c38cf4841ebf619e788790 inherit pub_types_classspiReader"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">status</a> { <br />
&#160;&#160;<b>ERROR</b> = 0x00, 
<b>FAILED_AUTH</b>, 
<b>SUCCESS</b>, 
<b>SUCCESS_NEWC</b>, 
<br />
&#160;&#160;<b>SUCCESS_OLDC</b>, 
<b>TIMEOUTCOM</b>, 
<b>TIMEOUTDEV</b>, 
<b>TIMEOUT</b>, 
<br />
&#160;&#160;<b>NO_SPACE</b>, 
<b>CRC_ERROR</b>, 
<b>CRC_SUCCESS</b>, 
<b>READY</b>
<br />
 }<tr class="memdesc:a4bcf984823c38cf4841ebf619e788790"><td class="mdescLeft">&#160;</td><td class="mdescRight">A status enum class.  <a href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4bcf984823c38cf4841ebf619e788790 inherit pub_types_classspiReader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f123bdc20d19e897c883ec12f1f0849"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a7f123bdc20d19e897c883ec12f1f0849">rc522</a> (hwlib::target::pin_out &amp;nssInput, hwlib::spi_bus_bit_banged_sclk_mosi_miso &amp;spiBusInput)</td></tr>
<tr class="memdesc:a7f123bdc20d19e897c883ec12f1f0849"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="#a7f123bdc20d19e897c883ec12f1f0849">More...</a><br /></td></tr>
<tr class="separator:a7f123bdc20d19e897c883ec12f1f0849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c225391f24da6a963e67b5e89f96be"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a98c225391f24da6a963e67b5e89f96be">readReg</a> (<a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a> regAddr)</td></tr>
<tr class="memdesc:a98c225391f24da6a963e67b5e89f96be"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read Register function returns uint8_t.  <a href="#a98c225391f24da6a963e67b5e89f96be">More...</a><br /></td></tr>
<tr class="separator:a98c225391f24da6a963e67b5e89f96be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398f2a0effc1a0acd48735d7d014c6e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a9398f2a0effc1a0acd48735d7d014c6e">readReg</a> (<a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a> regAddr)</td></tr>
<tr class="memdesc:a9398f2a0effc1a0acd48735d7d014c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read Register function returns uint8_t.  <a href="#a9398f2a0effc1a0acd48735d7d014c6e">More...</a><br /></td></tr>
<tr class="separator:a9398f2a0effc1a0acd48735d7d014c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96857ef5f6e2a9b4bc7e6901f65907b5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a96857ef5f6e2a9b4bc7e6901f65907b5">readReg</a> (<a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a> regAddr)</td></tr>
<tr class="memdesc:a96857ef5f6e2a9b4bc7e6901f65907b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read Register function returns uint8_t.  <a href="#a96857ef5f6e2a9b4bc7e6901f65907b5">More...</a><br /></td></tr>
<tr class="separator:a96857ef5f6e2a9b4bc7e6901f65907b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5a8b96bae53a3832e10054211f5064"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a1b5a8b96bae53a3832e10054211f5064">readReg</a> (<a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a> regAddr)</td></tr>
<tr class="memdesc:a1b5a8b96bae53a3832e10054211f5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">A read Register function returns uint8_t.  <a href="#a1b5a8b96bae53a3832e10054211f5064">More...</a><br /></td></tr>
<tr class="separator:a1b5a8b96bae53a3832e10054211f5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3045ab844b8de82e9a5f3504c82c8995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a3045ab844b8de82e9a5f3504c82c8995">writeReg</a> (<a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a> regAddr, uint8_t data)</td></tr>
<tr class="memdesc:a3045ab844b8de82e9a5f3504c82c8995"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write Register function.  <a href="#a3045ab844b8de82e9a5f3504c82c8995">More...</a><br /></td></tr>
<tr class="separator:a3045ab844b8de82e9a5f3504c82c8995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e748a997e22ef74e00c05f8d8383c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#aa8e748a997e22ef74e00c05f8d8383c5">writeReg</a> (<a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a> regAddr, uint8_t data)</td></tr>
<tr class="memdesc:aa8e748a997e22ef74e00c05f8d8383c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write Register function.  <a href="#aa8e748a997e22ef74e00c05f8d8383c5">More...</a><br /></td></tr>
<tr class="separator:aa8e748a997e22ef74e00c05f8d8383c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51979eca697dcfeddf2ef8795adf7851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a51979eca697dcfeddf2ef8795adf7851">writeReg</a> (<a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a> regAddr, uint8_t data)</td></tr>
<tr class="memdesc:a51979eca697dcfeddf2ef8795adf7851"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write Register function.  <a href="#a51979eca697dcfeddf2ef8795adf7851">More...</a><br /></td></tr>
<tr class="separator:a51979eca697dcfeddf2ef8795adf7851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6907bf656f821a89e636a1b8cf28fe60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a6907bf656f821a89e636a1b8cf28fe60">writeReg</a> (<a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a> regAddr, uint8_t data)</td></tr>
<tr class="memdesc:a6907bf656f821a89e636a1b8cf28fe60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write Register function.  <a href="#a6907bf656f821a89e636a1b8cf28fe60">More...</a><br /></td></tr>
<tr class="separator:a6907bf656f821a89e636a1b8cf28fe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458e303b33f57ed839c21e790f912191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a458e303b33f57ed839c21e790f912191">writeReg</a> (<a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a> regAddr, <a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">rc522::regCommands</a> data)</td></tr>
<tr class="memdesc:a458e303b33f57ed839c21e790f912191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write Register function.  <a href="#a458e303b33f57ed839c21e790f912191">More...</a><br /></td></tr>
<tr class="separator:a458e303b33f57ed839c21e790f912191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce878aa570ff9f611df399139229265"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adce878aa570ff9f611df399139229265"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#adce878aa570ff9f611df399139229265">writeReg</a> (<a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a> regAddr, std::array&lt; uint8_t, N &gt; data)</td></tr>
<tr class="memdesc:adce878aa570ff9f611df399139229265"><td class="mdescLeft">&#160;</td><td class="mdescRight">A write Register function for array of data.  <a href="#adce878aa570ff9f611df399139229265">More...</a><br /></td></tr>
<tr class="separator:adce878aa570ff9f611df399139229265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6643f07cb56370ce58605b4aa4bde1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a2a6643f07cb56370ce58605b4aa4bde1">setRegBitMask</a> (<a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:a2a6643f07cb56370ce58605b4aa4bde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a register bit with mask.  <a href="#a2a6643f07cb56370ce58605b4aa4bde1">More...</a><br /></td></tr>
<tr class="separator:a2a6643f07cb56370ce58605b4aa4bde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadff61e3733655710ea945c03137a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#acadff61e3733655710ea945c03137a39">setRegBitMask</a> (<a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:acadff61e3733655710ea945c03137a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a register bit with mask.  <a href="#acadff61e3733655710ea945c03137a39">More...</a><br /></td></tr>
<tr class="separator:acadff61e3733655710ea945c03137a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae350dcb495ec47cbb081b2fd9df35ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#aae350dcb495ec47cbb081b2fd9df35ff">setRegBitMask</a> (<a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:aae350dcb495ec47cbb081b2fd9df35ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a register bit with mask.  <a href="#aae350dcb495ec47cbb081b2fd9df35ff">More...</a><br /></td></tr>
<tr class="separator:aae350dcb495ec47cbb081b2fd9df35ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3752c747cd1cbb4510eaf24d363befe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#ac3752c747cd1cbb4510eaf24d363befe">setRegBitMask</a> (<a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:ac3752c747cd1cbb4510eaf24d363befe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a register bit with mask.  <a href="#ac3752c747cd1cbb4510eaf24d363befe">More...</a><br /></td></tr>
<tr class="separator:ac3752c747cd1cbb4510eaf24d363befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c7a632fbb1206326008025c522ef20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a18c7a632fbb1206326008025c522ef20">unsetRegBitMask</a> (<a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:a18c7a632fbb1206326008025c522ef20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset a register bit with mask.  <a href="#a18c7a632fbb1206326008025c522ef20">More...</a><br /></td></tr>
<tr class="separator:a18c7a632fbb1206326008025c522ef20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a055b560cb7e84801497a6acad1e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#ad5a055b560cb7e84801497a6acad1e70">unsetRegBitMask</a> (<a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:ad5a055b560cb7e84801497a6acad1e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset a register bit with mask.  <a href="#ad5a055b560cb7e84801497a6acad1e70">More...</a><br /></td></tr>
<tr class="separator:ad5a055b560cb7e84801497a6acad1e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf4ec7b5342e683310f526a1f10ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a1ebf4ec7b5342e683310f526a1f10ede">unsetRegBitMask</a> (<a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:a1ebf4ec7b5342e683310f526a1f10ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset a register bit with mask.  <a href="#a1ebf4ec7b5342e683310f526a1f10ede">More...</a><br /></td></tr>
<tr class="separator:a1ebf4ec7b5342e683310f526a1f10ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f345b15adb65750491a0bc4ccc7513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a52f345b15adb65750491a0bc4ccc7513">unsetRegBitMask</a> (<a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a> regAddr, uint8_t mask)</td></tr>
<tr class="memdesc:a52f345b15adb65750491a0bc4ccc7513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset a register bit with mask.  <a href="#a52f345b15adb65750491a0bc4ccc7513">More...</a><br /></td></tr>
<tr class="separator:a52f345b15adb65750491a0bc4ccc7513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2477eaf7d1f2f3123714cce6311d62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a9f2477eaf7d1f2f3123714cce6311d62">antennaOn</a> (bool feedback)</td></tr>
<tr class="memdesc:a9f2477eaf7d1f2f3123714cce6311d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns antenna On.  <a href="#a9f2477eaf7d1f2f3123714cce6311d62">More...</a><br /></td></tr>
<tr class="separator:a9f2477eaf7d1f2f3123714cce6311d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3318612b0a93b415415ef9e1a6b03dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a3318612b0a93b415415ef9e1a6b03dae">antennaOff</a> (bool feedback)</td></tr>
<tr class="memdesc:a3318612b0a93b415415ef9e1a6b03dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns antenna Off.  <a href="#a3318612b0a93b415415ef9e1a6b03dae">More...</a><br /></td></tr>
<tr class="separator:a3318612b0a93b415415ef9e1a6b03dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bfe75989ff8f654d412d7802993a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a60bfe75989ff8f654d412d7802993a53">softReset</a> ()</td></tr>
<tr class="memdesc:a60bfe75989ff8f654d412d7802993a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes soft reset.  <a href="#a60bfe75989ff8f654d412d7802993a53">More...</a><br /></td></tr>
<tr class="separator:a60bfe75989ff8f654d412d7802993a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a6b70c2d43ae0d22c608025ac55dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a49a6b70c2d43ae0d22c608025ac55dec">initialize</a> ()</td></tr>
<tr class="memdesc:a49a6b70c2d43ae0d22c608025ac55dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the chip.  <a href="#a49a6b70c2d43ae0d22c608025ac55dec">More...</a><br /></td></tr>
<tr class="separator:a49a6b70c2d43ae0d22c608025ac55dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c7bf4db9385aaa345c40f36ec929c"><td class="memItemLeft" align="right" valign="top">rc522::version&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a144c7bf4db9385aaa345c40f36ec929c">compareVersion</a> (std::array&lt; uint8_t, 64 &gt; buffer)</td></tr>
<tr class="memdesc:a144c7bf4db9385aaa345c40f36ec929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare supplied buffer with versions.  <a href="#a144c7bf4db9385aaa345c40f36ec929c">More...</a><br /></td></tr>
<tr class="separator:a144c7bf4db9385aaa345c40f36ec929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b0fd03ac296593e4b031a0308e3233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#ae2b0fd03ac296593e4b031a0308e3233">selfTest</a> ()</td></tr>
<tr class="memdesc:ae2b0fd03ac296593e4b031a0308e3233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the chips self test.  <a href="#ae2b0fd03ac296593e4b031a0308e3233">More...</a><br /></td></tr>
<tr class="separator:ae2b0fd03ac296593e4b031a0308e3233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3fe62ea90de72aa783331cf21f54fe"><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, unsigned int N2&gt; </td></tr>
<tr class="memitem:a6d3fe62ea90de72aa783331cf21f54fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#a6d3fe62ea90de72aa783331cf21f54fe">calcCRC</a> (std::array&lt; uint8_t, N1 &gt; &amp;dataIn, std::array&lt; uint8_t, N2 &gt; &amp;dataOut, bool containsCrc=false)</td></tr>
<tr class="memdesc:a6d3fe62ea90de72aa783331cf21f54fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate CRC of array.  <a href="#a6d3fe62ea90de72aa783331cf21f54fe">More...</a><br /></td></tr>
<tr class="separator:a6d3fe62ea90de72aa783331cf21f54fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034678819a3442934c55ba5c2f2588d"><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, unsigned int N2&gt; </td></tr>
<tr class="memitem:a4034678819a3442934c55ba5c2f2588d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#a4034678819a3442934c55ba5c2f2588d">cardCommunication</a> (std::array&lt; uint8_t, N1 &gt; &amp;bufSend, std::array&lt; uint8_t, N2 &gt; &amp;bufReceive, <a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">rc522::regCommands</a> comData, uint8_t bitFraming=0, uint8_t waitIrq=0, bool checkCrc=false)</td></tr>
<tr class="memdesc:a4034678819a3442934c55ba5c2f2588d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Communicate with card.  <a href="#a4034678819a3442934c55ba5c2f2588d">More...</a><br /></td></tr>
<tr class="separator:a4034678819a3442934c55ba5c2f2588d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcad63b7a87430ae943c833bcd9e24ab"><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, unsigned int N2&gt; </td></tr>
<tr class="memitem:adcad63b7a87430ae943c833bcd9e24ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#adcad63b7a87430ae943c833bcd9e24ab">cardTransceive</a> (std::array&lt; uint8_t, N1 &gt; &amp;bufSend, std::array&lt; uint8_t, N2 &gt; &amp;bufReceive, uint8_t bitFraming=0, bool checkCrc=false)</td></tr>
<tr class="memdesc:adcad63b7a87430ae943c833bcd9e24ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tranceives (Transmit &amp; Receive) to/from card.  <a href="#adcad63b7a87430ae943c833bcd9e24ab">More...</a><br /></td></tr>
<tr class="separator:adcad63b7a87430ae943c833bcd9e24ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa6f24387944a7aee98398dd300b7a0"><td class="memTemplParams" colspan="2">template&lt;unsigned int N1, unsigned int N2&gt; </td></tr>
<tr class="memitem:a4aa6f24387944a7aee98398dd300b7a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#a4aa6f24387944a7aee98398dd300b7a0">cardTransceive</a> (std::array&lt; mifare::command, N1 &gt; &amp;bufComData, std::array&lt; uint8_t, N2 &gt; &amp;bufReceive, uint8_t bitFraming=0, bool checkCrc=false)</td></tr>
<tr class="memdesc:a4aa6f24387944a7aee98398dd300b7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tranceives (Transmit &amp; Receive) to/from mifare card for array.  <a href="#a4aa6f24387944a7aee98398dd300b7a0">More...</a><br /></td></tr>
<tr class="separator:a4aa6f24387944a7aee98398dd300b7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998688cd59ae05add31c7c6847bf02ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a998688cd59ae05add31c7c6847bf02ae">wakeCard</a> (mifare::command comData)</td></tr>
<tr class="memdesc:a998688cd59ae05add31c7c6847bf02ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake up the card.  <a href="#a998688cd59ae05add31c7c6847bf02ae">More...</a><br /></td></tr>
<tr class="separator:a998688cd59ae05add31c7c6847bf02ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5016ad241df63301c261709debcb274b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a5016ad241df63301c261709debcb274b">selectCard</a> (<a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;curCard)</td></tr>
<tr class="memdesc:a5016ad241df63301c261709debcb274b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a mifare card.  <a href="#a5016ad241df63301c261709debcb274b">More...</a><br /></td></tr>
<tr class="separator:a5016ad241df63301c261709debcb274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cba68c4fff6e1acf8bf9b2601197d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a9cba68c4fff6e1acf8bf9b2601197d96">authenticateCard</a> (mifare::command comData, uint8_t blockAddr, <a class="el" href="classmifare_1_1card.html">mifare::card</a> cardData)</td></tr>
<tr class="memdesc:a9cba68c4fff6e1acf8bf9b2601197d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authenticate a block in mifare card.  <a href="#a9cba68c4fff6e1acf8bf9b2601197d96">More...</a><br /></td></tr>
<tr class="separator:a9cba68c4fff6e1acf8bf9b2601197d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f15a1c190dcde40f314ff4f6ffb65e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a0f15a1c190dcde40f314ff4f6ffb65e4">stopCrypto</a> ()</td></tr>
<tr class="memdesc:a0f15a1c190dcde40f314ff4f6ffb65e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops Crypto1 unit.  <a href="#a0f15a1c190dcde40f314ff4f6ffb65e4">More...</a><br /></td></tr>
<tr class="separator:a0f15a1c190dcde40f314ff4f6ffb65e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dfbf9cf9707a675c91981c92c93fdc"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:a87dfbf9cf9707a675c91981c92c93fdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#a87dfbf9cf9707a675c91981c92c93fdc">readBlock</a> (uint8_t blockAddr, std::array&lt; uint8_t, N &gt; &amp;bufReceive)</td></tr>
<tr class="memdesc:a87dfbf9cf9707a675c91981c92c93fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a block from mifare card.  <a href="#a87dfbf9cf9707a675c91981c92c93fdc">More...</a><br /></td></tr>
<tr class="separator:a87dfbf9cf9707a675c91981c92c93fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae660e16f131e5a28a4412b26d1f016a0"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:ae660e16f131e5a28a4412b26d1f016a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#ae660e16f131e5a28a4412b26d1f016a0">writeBlock</a> (uint8_t blockAddr, std::array&lt; uint8_t, N &gt; &amp;dataSend)</td></tr>
<tr class="memdesc:ae660e16f131e5a28a4412b26d1f016a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to block on mifare card.  <a href="#ae660e16f131e5a28a4412b26d1f016a0">More...</a><br /></td></tr>
<tr class="separator:ae660e16f131e5a28a4412b26d1f016a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eeb1eedf5ca47a44cab85a387156f3"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:aa0eeb1eedf5ca47a44cab85a387156f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#aa0eeb1eedf5ca47a44cab85a387156f3">executeRead</a> (uint8_t block, std::array&lt; uint8_t, N &gt; &amp;receiveBuf, <a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;card)</td></tr>
<tr class="memdesc:aa0eeb1eedf5ca47a44cab85a387156f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete read from mifare card.  <a href="#aa0eeb1eedf5ca47a44cab85a387156f3">More...</a><br /></td></tr>
<tr class="separator:aa0eeb1eedf5ca47a44cab85a387156f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab984cd49ca9affb679dded266c43f0"><td class="memTemplParams" colspan="2">template&lt;unsigned int N&gt; </td></tr>
<tr class="memitem:adab984cd49ca9affb679dded266c43f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#adab984cd49ca9affb679dded266c43f0">executeWrite</a> (uint8_t block, std::array&lt; uint8_t, N &gt; sendBuf, <a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;card)</td></tr>
<tr class="memdesc:adab984cd49ca9affb679dded266c43f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete write to mifare card.  <a href="#adab984cd49ca9affb679dded266c43f0">More...</a><br /></td></tr>
<tr class="separator:adab984cd49ca9affb679dded266c43f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3183014b1670c6c3cdb47ec857967476"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a3183014b1670c6c3cdb47ec857967476">findCard</a> (bool showInfo)</td></tr>
<tr class="memdesc:a3183014b1670c6c3cdb47ec857967476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find mifare card and wake it up.  <a href="#a3183014b1670c6c3cdb47ec857967476">More...</a><br /></td></tr>
<tr class="separator:a3183014b1670c6c3cdb47ec857967476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f4af5f03ac07d17918880e4f9e09c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#a69f4af5f03ac07d17918880e4f9e09c3">writeSheetToCard</a> (<a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;card, <a class="el" href="classsheet.html">sheet</a> character)</td></tr>
<tr class="memdesc:a69f4af5f03ac07d17918880e4f9e09c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write sheet to mifare card.  <a href="#a69f4af5f03ac07d17918880e4f9e09c3">More...</a><br /></td></tr>
<tr class="separator:a69f4af5f03ac07d17918880e4f9e09c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad265d81264eecf2124ad224c89d6c8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrc522.html#ad265d81264eecf2124ad224c89d6c8e7">readSheetFromCard</a> (<a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;card, <a class="el" href="classsheet.html">sheet</a> &amp;character)</td></tr>
<tr class="memdesc:ad265d81264eecf2124ad224c89d6c8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read sheet from mifare card.  <a href="#ad265d81264eecf2124ad224c89d6c8e7">More...</a><br /></td></tr>
<tr class="separator:ad265d81264eecf2124ad224c89d6c8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8930234e6cc3aa99ae679001d0ea9e86"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a8930234e6cc3aa99ae679001d0ea9e86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrc522.html#a8930234e6cc3aa99ae679001d0ea9e86">tryFunction</a> (F f, uint8_t tryFor=10)</td></tr>
<tr class="memdesc:a8930234e6cc3aa99ae679001d0ea9e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try a function x times.  <a href="#a8930234e6cc3aa99ae679001d0ea9e86">More...</a><br /></td></tr>
<tr class="separator:a8930234e6cc3aa99ae679001d0ea9e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classspiReader"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classspiReader')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classspiReader.html">spiReader</a></td></tr>
<tr class="memitem:af8eca236eb5cfe4e806f0151227e42b4 inherit pub_methods_classspiReader"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspiReader.html#af8eca236eb5cfe4e806f0151227e42b4">spiReader</a> (hwlib::target::pin_out &amp;nssInput, hwlib::spi_bus_bit_banged_sclk_mosi_miso &amp;spiBusInput)</td></tr>
<tr class="memdesc:af8eca236eb5cfe4e806f0151227e42b4 inherit pub_methods_classspiReader"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="classspiReader.html#af8eca236eb5cfe4e806f0151227e42b4">More...</a><br /></td></tr>
<tr class="separator:af8eca236eb5cfe4e806f0151227e42b4 inherit pub_methods_classspiReader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a77e00b5070f1c24350d4ac87566837fd"><td class="memItemLeft" align="right" valign="top"><a id="a77e00b5070f1c24350d4ac87566837fd"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>version</b> { <b>error</b> = 0, 
<b>version1</b>, 
<b>version2</b>
 }</td></tr>
<tr class="separator:a77e00b5070f1c24350d4ac87566837fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classspiReader"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classspiReader')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classspiReader.html">spiReader</a></td></tr>
<tr class="memitem:a2a241a80ce921c4df38b3080d839850f inherit pro_attribs_classspiReader"><td class="memItemLeft" align="right" valign="top">hwlib::target::pin_out &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspiReader.html#a2a241a80ce921c4df38b3080d839850f">nss</a></td></tr>
<tr class="memdesc:a2a241a80ce921c4df38b3080d839850f inherit pro_attribs_classspiReader"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nss hwlib pin_out by ref.  <a href="classspiReader.html#a2a241a80ce921c4df38b3080d839850f">More...</a><br /></td></tr>
<tr class="separator:a2a241a80ce921c4df38b3080d839850f inherit pro_attribs_classspiReader"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb87e7c8ca2a11337b67fe8efce50262 inherit pro_attribs_classspiReader"><td class="memItemLeft" align="right" valign="top">hwlib::spi_bus_bit_banged_sclk_mosi_miso&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspiReader.html#adb87e7c8ca2a11337b67fe8efce50262">spiBus</a></td></tr>
<tr class="memdesc:adb87e7c8ca2a11337b67fe8efce50262 inherit pro_attribs_classspiReader"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spiBus hwlib spi_bus_bit_banged_sclk_mosi_miso.  <a href="classspiReader.html#adb87e7c8ca2a11337b67fe8efce50262">More...</a><br /></td></tr>
<tr class="separator:adb87e7c8ca2a11337b67fe8efce50262 inherit pro_attribs_classspiReader"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classrc522.html" title="rc522 chip class inherits from spiReader ">rc522</a> chip class inherits from <a class="el" href="classspiReader.html" title="spiReader ADT class ">spiReader</a> </p>
<p>A class that inherits from the <a class="el" href="classspiReader.html" title="spiReader ADT class ">spiReader</a> ADT class. We need to supply the parameters for the <a class="el" href="classspiReader.html" title="spiReader ADT class ">spiReader</a> class and define the read and write functions. This class supplies all the registers and basic functionality for the <a class="el" href="classrc522.html" title="rc522 chip class inherits from spiReader ">rc522</a> chip. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6df2359c88d6c2f47faf58bc9e09eaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df2359c88d6c2f47faf58bc9e09eaa4">&#9670;&nbsp;</a></span>commands</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A enum class with Addressable Commands. </p>
<p>This enum class supports all the supplied commands from the documentation of the chip. </p>

</div>
</div>
<a id="afcf27c8198d017cd4e8173c7d7a6fded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf27c8198d017cd4e8173c7d7a6fded">&#9670;&nbsp;</a></span>configuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A enum class with Addressable Configuration registers. </p>
<p>This enum class supports all the supplied configuration registers from the documentation of the chip. </p>

</div>
</div>
<a id="a3a205976fb9b7265bc5b7971215fbb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a205976fb9b7265bc5b7971215fbb7c">&#9670;&nbsp;</a></span>regCommands</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">rc522::regCommands</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A enum class with register commands for the CommandReg. </p>
<p>This enum class supports all the supplied command from the documentation of the chip for the CommandReg. </p>

</div>
</div>
<a id="a83057db5f8fefa3dc9a6e8e5f0e191ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83057db5f8fefa3dc9a6e8e5f0e191ee">&#9670;&nbsp;</a></span>registers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A enum class with Addressable Registers. </p>
<p>This enum class supports all the supplied registers from the documentation of the chip. </p>

</div>
</div>
<a id="a9589917c9bbcd18ea9c7d86c7ec565bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9589917c9bbcd18ea9c7d86c7ec565bd">&#9670;&nbsp;</a></span>test</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A enum class with Addressable Test registers. </p>
<p>This enum class supports all the supplied test registers from the documentation of the chip. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7f123bdc20d19e897c883ec12f1f0849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f123bdc20d19e897c883ec12f1f0849">&#9670;&nbsp;</a></span>rc522()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rc522::rc522 </td>
          <td>(</td>
          <td class="paramtype">hwlib::target::pin_out &amp;&#160;</td>
          <td class="paramname"><em>nssInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::spi_bus_bit_banged_sclk_mosi_miso &amp;&#160;</td>
          <td class="paramname"><em>spiBusInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default constructor. </p>
<p>You need to supply the nss pin_out pin and the spiBus spi_bus_bit_banged_sclk_mosi_miso<br />
for the <a class="el" href="classspiReader.html" title="spiReader ADT class ">spiReader</a> class since there are no default values. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3318612b0a93b415415ef9e1a6b03dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3318612b0a93b415415ef9e1a6b03dae">&#9670;&nbsp;</a></span>antennaOff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::antennaOff </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>feedback</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns antenna Off. </p>
<p>The antennaOff function turn the antenna off.<br />
If you supply a true value for the feedback parameter the function will output a before and after state of the rc522::commands::TxControlReg.<br />
Using this function while the antenna is off does not turn the antenna on, so you can use it multiple times in succesion. </p>

</div>
</div>
<a id="a9f2477eaf7d1f2f3123714cce6311d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2477eaf7d1f2f3123714cce6311d62">&#9670;&nbsp;</a></span>antennaOn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::antennaOn </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>feedback</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns antenna On. </p>
<p>The antennaOn function turn the antenna on.<br />
If you supply a true value for the feedback parameter the function will output a before and after state of the rc522::commands::TxControlReg.<br />
Using this function while the antenna is on does not turn the antenna off, so you can use it multiple times in succesion. </p>

</div>
</div>
<a id="a9cba68c4fff6e1acf8bf9b2601197d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cba68c4fff6e1acf8bf9b2601197d96">&#9670;&nbsp;</a></span>authenticateCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::authenticateCard </td>
          <td>(</td>
          <td class="paramtype">mifare::command&#160;</td>
          <td class="paramname"><em>comData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmifare_1_1card.html">mifare::card</a>&#160;</td>
          <td class="paramname"><em>cardData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authenticate a block in mifare card. </p>
<p>This function tries to authenticate a block on a mifare card.<br />
You need to either supply a mifare::command::authKA or mifare::command::authKB mifare::command.<br />
You also need to supply a uint8_t value containing the address of the block you want to authenticate.<br />
Next you need to supply a <a class="el" href="classmifare_1_1card.html" title="A card class for mifare cards. ">mifare::card</a> which will be used to get the key associated with the card,<br />
the maximum amount of available block and the UID.<br />
This function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS means the authenticate action was successfull. </p>

</div>
</div>
<a id="a6d3fe62ea90de72aa783331cf21f54fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3fe62ea90de72aa783331cf21f54fe">&#9670;&nbsp;</a></span>calcCRC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N1, unsigned int N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::calcCRC </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>containsCrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate CRC of array. </p>
<p>The calcCRC function calculates 2 CRC values based on the first and last value in the supplied array.<br />
You need to supply dataIn array with a maximum size of 64 and a dataOut array with a minimum size of 2.<br />
If your dataIn array contains a CRC you can supply the containsCrc parameter with a true value and the function will<br />
 fill a temporary array with the data from dataIn - the last 2 bytes which contain the CRC calulations. The function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS when the CRC was successfull. </p>

</div>
</div>
<a id="a4034678819a3442934c55ba5c2f2588d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4034678819a3442934c55ba5c2f2588d">&#9670;&nbsp;</a></span>cardCommunication()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N1, unsigned int N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::cardCommunication </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">rc522::regCommands</a>&#160;</td>
          <td class="paramname"><em>comData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitFraming</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>waitIrq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkCrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Communicate with card. </p>
<p>This function handles communication with a card.<br />
You need to supply a bufSend array with a maximum size of 64,<br />
a bufReceive array to receive the returned data,<br />
a command to execute in the form of a <a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c" title="A enum class with register commands for the CommandReg. ">rc522::regCommands</a> command.<br />
If you want you can also send the bit frame along, its default value is set to 0 which means all bits are needed.<br />
You can also send the waitIrq value along, its default value is set to 0 which means that there are no interupt bits set.<br />
You can also send a checkCrc bool along, its default is set to false which means that the function will not check the CRC.<br />
The function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS the communication went successfull. </p>

</div>
</div>
<a id="adcad63b7a87430ae943c833bcd9e24ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcad63b7a87430ae943c833bcd9e24ab">&#9670;&nbsp;</a></span>cardTransceive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N1, unsigned int N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::cardTransceive </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitFraming</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkCrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tranceives (Transmit &amp; Receive) to/from card. </p>
<p>This function calls the cardCommunication function with some default values such as the rc522::regCommands::Transceive command.<br />
You need to supply a bufSend array with a maximum size of 64.<br />
You also need to supply a bufReceive array for the returned data.<br />
If you want you can also send the bit frame along, its default value is set to 0 which means all bits are needed.<br />
You can also send a checkCrc bool along, its default is set to false which means that the function will not check the CRC.<br />
The function will set the waitIrq to 0x30 which sets the RxIRq and IdleIRq bits. </p>

</div>
</div>
<a id="a4aa6f24387944a7aee98398dd300b7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa6f24387944a7aee98398dd300b7a0">&#9670;&nbsp;</a></span>cardTransceive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N1, unsigned int N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::cardTransceive </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; mifare::command, N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufComData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufReceive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitFraming</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkCrc</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tranceives (Transmit &amp; Receive) to/from mifare card for array. </p>
<p>This function calls the cardCommunication function with some default values such as the rc522::regCommands::Transceive command.<br />
You need to supply a bufComData array containing a single or multiple mifare::command 's.<br />
You also need to supply a bufReceive array for the returned data.<br />
If you want you can also send the bit frame along, its default value is set to 0 which means all bits are needed.<br />
You can also send a checkCrc bool along, its default is set to false which means that the function will not check the CRC.<br />
The function will set the waitIrq to 0x30 which sets the RxIRq and IdleIRq bits. </p>

</div>
</div>
<a id="a144c7bf4db9385aaa345c40f36ec929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c7bf4db9385aaa345c40f36ec929c">&#9670;&nbsp;</a></span>compareVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rc522::version rc522::compareVersion </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, 64 &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare supplied buffer with versions. </p>
<p>The compareVersion function compares the supplied buffer array with 2 arrays to see which version the user has. </p>

</div>
</div>
<a id="aa0eeb1eedf5ca47a44cab85a387156f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eeb1eedf5ca47a44cab85a387156f3">&#9670;&nbsp;</a></span>executeRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::executeRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiveBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;&#160;</td>
          <td class="paramname"><em>card</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete read from mifare card. </p>
<p>This function performs all the necessary steps for a read from a mifare block.<br />
First we select the card using the <a class="el" href="classrc522.html#a5016ad241df63301c261709debcb274b" title="Select a mifare card. ">selectCard()</a> function.<br />
Next we authenticate for the block we want to read using the <a class="el" href="classrc522.html#a9cba68c4fff6e1acf8bf9b2601197d96" title="Authenticate a block in mifare card. ">authenticateCard()</a> function.<br />
Then we read from the block using the <a class="el" href="classrc522.html#a87dfbf9cf9707a675c91981c92c93fdc" title="Read a block from mifare card. ">readBlock()</a> function and we use the <a class="el" href="classrc522.html#a0f15a1c190dcde40f314ff4f6ffb65e4" title="Stops Crypto1 unit. ">stopCrypto()</a> function to safely exit the function.<br />
We wait occasionally wait for 5 ms because the card needs some time to respond to our commands.<br />
We return a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, rc522::status::SUCCESS means we successfully read. </p>

</div>
</div>
<a id="adab984cd49ca9affb679dded266c43f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab984cd49ca9affb679dded266c43f0">&#9670;&nbsp;</a></span>executeWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::executeWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N &gt;&#160;</td>
          <td class="paramname"><em>sendBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;&#160;</td>
          <td class="paramname"><em>card</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complete write to mifare card. </p>
<p>This function performs all the necessary steps for a write to a mifare block.<br />
First we select the card using the <a class="el" href="classrc522.html#a5016ad241df63301c261709debcb274b" title="Select a mifare card. ">selectCard()</a> function.<br />
Next we authenticate for the block we want to write to using the <a class="el" href="classrc522.html#a9cba68c4fff6e1acf8bf9b2601197d96" title="Authenticate a block in mifare card. ">authenticateCard()</a> function.<br />
Then we write to the block using the <a class="el" href="classrc522.html#ae660e16f131e5a28a4412b26d1f016a0" title="Write to block on mifare card. ">writeBlock()</a> function and we use the <a class="el" href="classrc522.html#a0f15a1c190dcde40f314ff4f6ffb65e4" title="Stops Crypto1 unit. ">stopCrypto()</a> function to safely exit the function.<br />
We wait occasionally wait for 5 ms because the card needs some time to respond to our commands. We return a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, rc522::status::SUCCESS means we successfully wrote. </p>

</div>
</div>
<a id="a3183014b1670c6c3cdb47ec857967476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3183014b1670c6c3cdb47ec857967476">&#9670;&nbsp;</a></span>findCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rc522::findCard </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showInfo</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find mifare card and wake it up. </p>
<p>This function tries to find a mifare card in the vicinity.<br />
It tries to send a REQA and a WUPA 10 times before stopping and returning false.<br />
On a successfull wake up it returns true. </p>

</div>
</div>
<a id="a49a6b70c2d43ae0d22c608025ac55dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a6b70c2d43ae0d22c608025ac55dec">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the chip. </p>
<p>We perform a softReset, and then we reset the baud rates and the modulation width.<br />
We also configure certain registers in preperation for when things go wrong,<br />
we do so by configuring the timers so we can get time outs.<br />
Next we configure the CRC and turn the antenna on. </p>

</div>
</div>
<a id="a87dfbf9cf9707a675c91981c92c93fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dfbf9cf9707a675c91981c92c93fdc">&#9670;&nbsp;</a></span>readBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::readBlock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufReceive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a block from mifare card. </p>
<p>This function reads a single block from a mifare card.<br />
You need to supply a uint8_t value which contains the block you want to read from.<br />
You also need to supply a bufReceive array with a minimum size of 18.<br />
We need at least 18 bytes, 16 for all the bytes from the block and 2 for the CRC at the end. This function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS means the read action was successfull. </p>

</div>
</div>
<a id="a98c225391f24da6a963e67b5e89f96be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c225391f24da6a963e67b5e89f96be">&#9670;&nbsp;</a></span>readReg() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rc522::readReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a>&#160;</td>
          <td class="paramname"><em>regAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A read Register function returns uint8_t. </p>
<p>The readReg function using the commands enum class.<br />
You need to supply a <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4" title="A enum class with Addressable Commands. ">rc522::commands</a> to read from, the functions returns a uint8_t. </p>

</div>
</div>
<a id="a9398f2a0effc1a0acd48735d7d014c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398f2a0effc1a0acd48735d7d014c6e">&#9670;&nbsp;</a></span>readReg() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rc522::readReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a>&#160;</td>
          <td class="paramname"><em>regAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A read Register function returns uint8_t. </p>
<p>The readReg function using the registers enum class.<br />
You need to supply a <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> to read from, the functions returns a uint8_t. </p>

</div>
</div>
<a id="a96857ef5f6e2a9b4bc7e6901f65907b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96857ef5f6e2a9b4bc7e6901f65907b5">&#9670;&nbsp;</a></span>readReg() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rc522::readReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a>&#160;</td>
          <td class="paramname"><em>regAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A read Register function returns uint8_t. </p>
<p>The readReg function using the configuration enum class.<br />
You need to supply a <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded" title="A enum class with Addressable Configuration registers. ">rc522::configuration</a> to read from, the functions returns a uint8_t. </p>

</div>
</div>
<a id="a1b5a8b96bae53a3832e10054211f5064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5a8b96bae53a3832e10054211f5064">&#9670;&nbsp;</a></span>readReg() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rc522::readReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a>&#160;</td>
          <td class="paramname"><em>regAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A read Register function returns uint8_t. </p>
<p>The readReg function using the test enum class.<br />
You need to supply a <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd" title="A enum class with Addressable Test registers. ">rc522::test</a> to read from, the functions returns a uint8_t. </p>

</div>
</div>
<a id="ad265d81264eecf2124ad224c89d6c8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad265d81264eecf2124ad224c89d6c8e7">&#9670;&nbsp;</a></span>readSheetFromCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::readSheetFromCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsheet.html">sheet</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read sheet from mifare card. </p>
<p>This function reads a complete sheet from the mifare card.<br />
You need to supply a <a class="el" href="classmifare_1_1card.html" title="A card class for mifare cards. ">mifare::card</a> and a sheet to write the data to.<br />
Using the <a class="el" href="classrc522.html#aa0eeb1eedf5ca47a44cab85a387156f3" title="Complete read from mifare card. ">executeRead()</a> function we read data and check the returned <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>.<br />
On a successfull read of the sheet we return rc522::status::SUCCESS. </p>

</div>
</div>
<a id="a5016ad241df63301c261709debcb274b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5016ad241df63301c261709debcb274b">&#9670;&nbsp;</a></span>selectCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::selectCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;&#160;</td>
          <td class="paramname"><em>curCard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select a mifare card. </p>
<p>This function is used to select a mifare card.<br />
You need to supply a <a class="el" href="classmifare_1_1card.html" title="A card class for mifare cards. ">mifare::card</a> in which the selected cards UID will be stored.<br />
First we send a anti-colision command to the card which will return a UID with a back character check.<br />
After checking the BCC we store the UID in the <a class="el" href="classmifare_1_1card.html" title="A card class for mifare cards. ">mifare::card</a>.<br />
Next we try to select the card so we send the select command including the CRC values.<br />
For now the function only support the MF1S503yX version which has a NUID with a size of 4 bytes. This function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS means the select action was successfull. </p>

</div>
</div>
<a id="ae2b0fd03ac296593e4b031a0308e3233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b0fd03ac296593e4b031a0308e3233">&#9670;&nbsp;</a></span>selfTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::selfTest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the chips self test. </p>
<p>This is the self test as described in the documentation of the <a class="el" href="classrc522.html" title="rc522 chip class inherits from spiReader ">rc522</a> chip.<br />
In this test we also compare the chips version with the compareVersion function. </p>

</div>
</div>
<a id="a2a6643f07cb56370ce58605b4aa4bde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6643f07cb56370ce58605b4aa4bde1">&#9670;&nbsp;</a></span>setRegBitMask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::setRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a register bit with mask. </p>
<p>The setRegBitMask sets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4" title="A enum class with Addressable Commands. ">rc522::commands</a> and a uint8_t value as the mask.<br />
The mask will set the bits that are not set in the supplied <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4" title="A enum class with Addressable Commands. ">rc522::commands</a> register,<br />
and will not unset bits that are set. </p>

</div>
</div>
<a id="acadff61e3733655710ea945c03137a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadff61e3733655710ea945c03137a39">&#9670;&nbsp;</a></span>setRegBitMask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::setRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a register bit with mask. </p>
<p>The setRegBitMask sets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> and a uint8_t value as the mask.<br />
The mask will set the bits that are not set in the supplied <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> register,<br />
and will not unset bits that are set. </p>

</div>
</div>
<a id="aae350dcb495ec47cbb081b2fd9df35ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae350dcb495ec47cbb081b2fd9df35ff">&#9670;&nbsp;</a></span>setRegBitMask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::setRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a register bit with mask. </p>
<p>The setRegBitMask sets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded" title="A enum class with Addressable Configuration registers. ">rc522::configuration</a> and a uint8_t value as the mask.<br />
The mask will set the bits that are not set in the supplied <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded" title="A enum class with Addressable Configuration registers. ">rc522::configuration</a> register,<br />
and will not unset bits that are set. </p>

</div>
</div>
<a id="ac3752c747cd1cbb4510eaf24d363befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3752c747cd1cbb4510eaf24d363befe">&#9670;&nbsp;</a></span>setRegBitMask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::setRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a register bit with mask. </p>
<p>The setRegBitMask sets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd" title="A enum class with Addressable Test registers. ">rc522::test</a> and a uint8_t value as the mask.<br />
The mask will set the bits that are not set in the supplied <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd" title="A enum class with Addressable Test registers. ">rc522::test</a> register,<br />
and will not unset bits that are set. </p>

</div>
</div>
<a id="a60bfe75989ff8f654d412d7802993a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bfe75989ff8f654d412d7802993a53">&#9670;&nbsp;</a></span>softReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::softReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes soft reset. </p>
<p>The softReset function performs a soft reset by writing the rc522::regCommands::SoftReset command to the rc522::registers::CommandReg register.<br />
We wait for a maximum of 10 loops with a wait of 25 ms so the crystal can start-up or until the power-bit is cleared. </p>

</div>
</div>
<a id="a0f15a1c190dcde40f314ff4f6ffb65e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f15a1c190dcde40f314ff4f6ffb65e4">&#9670;&nbsp;</a></span>stopCrypto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::stopCrypto </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops Crypto1 unit. </p>
<p>This function unsets the mifare Crypto1 bit. </p>

</div>
</div>
<a id="a8930234e6cc3aa99ae679001d0ea9e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8930234e6cc3aa99ae679001d0ea9e86">&#9670;&nbsp;</a></span>tryFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::tryFunction </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tryFor</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try a function x times. </p>
<p>This function tries to execute x times until the <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a> we receive is a rc522::status::SUCCESS.<br />
You need to supply a lambda function that needs the return type of the function to be <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>.<br />
You can also supply a uint8_t value which is the amount of times this function will try to exectute this function,<br />
 default value is 10.<br />
This function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS means the function was executed successfully. </p>

</div>
</div>
<a id="a18c7a632fbb1206326008025c522ef20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c7a632fbb1206326008025c522ef20">&#9670;&nbsp;</a></span>unsetRegBitMask() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::unsetRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset a register bit with mask. </p>
<p>The unsetRegBitMask unsets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4" title="A enum class with Addressable Commands. ">rc522::commands</a> and a uint8_t value as the mask.<br />
The mask will unset the bits that are set in the supplied <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4" title="A enum class with Addressable Commands. ">rc522::commands</a> register,<br />
and will not set bits that are unset. </p>

</div>
</div>
<a id="ad5a055b560cb7e84801497a6acad1e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a055b560cb7e84801497a6acad1e70">&#9670;&nbsp;</a></span>unsetRegBitMask() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::unsetRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset a register bit with mask. </p>
<p>The unsetRegBitMask unsets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> and a uint8_t value as the mask.<br />
The mask will unset the bits that are set in the supplied <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> register,<br />
and will not set bits that are unset. </p>

</div>
</div>
<a id="a1ebf4ec7b5342e683310f526a1f10ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf4ec7b5342e683310f526a1f10ede">&#9670;&nbsp;</a></span>unsetRegBitMask() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::unsetRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset a register bit with mask. </p>
<p>The unsetRegBitMask unsets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded" title="A enum class with Addressable Configuration registers. ">rc522::configuration</a> and a uint8_t value as the mask.<br />
The mask will unset the bits that are set in the supplied <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded" title="A enum class with Addressable Configuration registers. ">rc522::configuration</a> register,<br />
and will not set bits that are unset. </p>

</div>
</div>
<a id="a52f345b15adb65750491a0bc4ccc7513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f345b15adb65750491a0bc4ccc7513">&#9670;&nbsp;</a></span>unsetRegBitMask() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::unsetRegBitMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset a register bit with mask. </p>
<p>The unsetRegBitMask unsets certain bits with the supplied mask.<br />
You need to supply a <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd" title="A enum class with Addressable Test registers. ">rc522::test</a> and a uint8_t value as the mask.<br />
The mask will unset the bits that are set in the supplied <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd" title="A enum class with Addressable Test registers. ">rc522::test</a> register,<br />
and will not set bits that are unset. </p>

</div>
</div>
<a id="a998688cd59ae05add31c7c6847bf02ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998688cd59ae05add31c7c6847bf02ae">&#9670;&nbsp;</a></span>wakeCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::wakeCard </td>
          <td>(</td>
          <td class="paramtype">mifare::command&#160;</td>
          <td class="paramname"><em>comData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wake up the card. </p>
<p>This function is used to wake a mifare card up.<br />
You need to supply a mifare::command.<br />
We set the bit frame to 7 because in the mifare protocol the REQA and WUPA need to be in a 7 bits frame.<br />
The function return a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, rc522::status::SUCCESS if we succesfully woke the card up. </p>

</div>
</div>
<a id="ae660e16f131e5a28a4412b26d1f016a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae660e16f131e5a28a4412b26d1f016a0">&#9670;&nbsp;</a></span>writeBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::writeBlock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>blockAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>dataSend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to block on mifare card. </p>
<p>This function writes 16 bytes to a block on a mifare card.<br />
You need to supply a uint8_t value containing the block address.<br />
You also need to supply a dataSend array a maximum size of 16.<br />
This function will first send a mifare::command::write to the card.<br />
Then we wait for 1 ms so the card has time to send ACK or NACK.<br />
Next we write the data to the card.<br />
This function returns a <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>, a rc522::status::SUCCESS means the write action was successfull. </p>

</div>
</div>
<a id="a3045ab844b8de82e9a5f3504c82c8995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3045ab844b8de82e9a5f3504c82c8995">&#9670;&nbsp;</a></span>writeReg() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::writeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4">rc522::commands</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A write Register function. </p>
<p>The writeReg function using the commands enum class.<br />
You need to supply a <a class="el" href="classrc522.html#a6df2359c88d6c2f47faf58bc9e09eaa4" title="A enum class with Addressable Commands. ">rc522::commands</a> to write to.<br />
You also need to supply a uint8_t containing the 8 bits to write to the register.<br />
 </p>

</div>
</div>
<a id="aa8e748a997e22ef74e00c05f8d8383c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e748a997e22ef74e00c05f8d8383c5">&#9670;&nbsp;</a></span>writeReg() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::writeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A write Register function. </p>
<p>The writeReg function using the registers enum class.<br />
You need to supply a <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> to write to.<br />
You also need to supply a uint8_t containing the 8 bits to write to the register.<br />
 </p>

</div>
</div>
<a id="a51979eca697dcfeddf2ef8795adf7851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51979eca697dcfeddf2ef8795adf7851">&#9670;&nbsp;</a></span>writeReg() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::writeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded">rc522::configuration</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A write Register function. </p>
<p>The writeReg function using the configuration enum class.<br />
You need to supply a <a class="el" href="classrc522.html#afcf27c8198d017cd4e8173c7d7a6fded" title="A enum class with Addressable Configuration registers. ">rc522::configuration</a> to write to.<br />
You also need to supply a uint8_t containing the 8 bits to write to the register.<br />
 </p>

</div>
</div>
<a id="a6907bf656f821a89e636a1b8cf28fe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6907bf656f821a89e636a1b8cf28fe60">&#9670;&nbsp;</a></span>writeReg() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::writeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd">rc522::test</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A write Register function. </p>
<p>The writeReg function using the test enum class.<br />
You need to supply a <a class="el" href="classrc522.html#a9589917c9bbcd18ea9c7d86c7ec565bd" title="A enum class with Addressable Test registers. ">rc522::test</a> to write to.<br />
You also need to supply a uint8_t containing the 8 bits to write to the register.<br />
 </p>

</div>
</div>
<a id="a458e303b33f57ed839c21e790f912191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458e303b33f57ed839c21e790f912191">&#9670;&nbsp;</a></span>writeReg() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::writeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c">rc522::regCommands</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A write Register function. </p>
<p>The writeReg function using the registers enum class, specifically for the CommandReg.<br />
You need to supply a <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> to write to.<br />
You also need to supply a <a class="el" href="classrc522.html#a3a205976fb9b7265bc5b7971215fbb7c" title="A enum class with register commands for the CommandReg. ">rc522::regCommands</a> to write to the register.<br />
 </p>

</div>
</div>
<a id="adce878aa570ff9f611df399139229265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce878aa570ff9f611df399139229265">&#9670;&nbsp;</a></span>writeReg() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rc522::writeReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee">rc522::registers</a>&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; uint8_t, N &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A write Register function for array of data. </p>
<p>The writeReg function using the registers enum class, specifically for the .<br />
You need to supply a <a class="el" href="classrc522.html#a83057db5f8fefa3dc9a6e8e5f0e191ee" title="A enum class with Addressable Registers. ">rc522::registers</a> to write to.<br />
You also need to supply a array with type uint8_t and with a maximum size of 64 to write to the register.<br />
 </p>

</div>
</div>
<a id="a69f4af5f03ac07d17918880e4f9e09c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f4af5f03ac07d17918880e4f9e09c3">&#9670;&nbsp;</a></span>writeSheetToCard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790">rc522::status</a> rc522::writeSheetToCard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmifare_1_1card.html">mifare::card</a> &amp;&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsheet.html">sheet</a>&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write sheet to mifare card. </p>
<p>This function writes a complete sheet to the mifare card.<br />
You need to supply a <a class="el" href="classmifare_1_1card.html" title="A card class for mifare cards. ">mifare::card</a> and a sheet containg the data to write.<br />
Using the <a class="el" href="classrc522.html#adab984cd49ca9affb679dded266c43f0" title="Complete write to mifare card. ">executeWrite()</a> function we write data and check the returned <a class="el" href="classspiReader.html#a4bcf984823c38cf4841ebf619e788790" title="A status enum class. ">rc522::status</a>.<br />
On a successfull write of the sheet we return rc522::status::SUCCESS. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="rc522_8hpp_source.html">rc522.hpp</a></li>
<li>rc522.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
